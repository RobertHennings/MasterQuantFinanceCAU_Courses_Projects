import pandas as pd
import numpy as np
import matplotlib.pyplot as plt

"""
Description:
In what follows is the implementation of the stochastic integral in matrix form
following along the lines of page 37. The asset processes are here generated by
a simple (standard) normal law, what can be replaced by any desired law for toy
simulation or by a real asset price time series. Also the position sizes are here
just drawn randomly in a given, non fractional, range, what can be replaced by
more reasistic scenarios as it here serves only for showing variations for the
simulation.
"""

def main():
    number_of_assets = 20
    discrete_periods = 100
    sd_processes = 1
    mean_process = 0
    start_process = 10
    low_position_size = -5
    high_position_size = 5

    def generate_portfolio_process(number_of_assets: int, discrete_periods: int,
                                   start_process: float, sd_processes: float,
                                   mean_process: float, low_position_size: int,
                                   high_position_size: int) -> pd.DataFrame:
        """Generates, by matrix multiplications, the evolution of the single positions
           over time and the wealth evolution of the whole portfolio itself 

        Args:
            number_of_assets (int): assets for portfolio
            discrete_periods (int): number of time periods to run
            start_process (float): starting value for simulation for asset prices
            sd_processes (float): sd for simulation for asset prices
            mean_process (float): mean for simulation for asset prices
            low_position_size (int): lower bound for position sizes held
            high_position_size (int): upper bound for position sizes held

        Returns:
            pd.DataFrame: position_evolution_df holding the single position evolutions
                          over time, columns being n time periods, rows as assets, entries
                          as position values
                          portfolio_wealth_df: wealth evolution of whole portfolio
        """
        # First get the H matrix for the position sizes
        size_H = number_of_assets * discrete_periods
        H = np.random.randint(low=low_position_size, high=high_position_size,
                              size=size_H).reshape((number_of_assets, discrete_periods))

        # Get the raw single period fixed asset prices
        size_X = number_of_assets * (discrete_periods+1)
        X = start_process * np.random.normal(loc=mean_process, scale=sd_processes, size=size_X).reshape((number_of_assets, discrete_periods+1))

        # Compute the asset price deltas in each row, loose one column of the matrix
        X_delta = np.diff(X)

        # for analyzing the evolution of every single asset we have to follow a scalar approach
        position_evolution = H * X_delta
        position_evolution_df = pd.DataFrame(position_evolution, 
                                            index=[f"Asset_{n}" for n in range(position_evolution.shape[0])],
                                            columns=[f"P_{n}" for n in range(1, position_evolution.shape[1]+1)])

        # Compute the evolving wealth for each position and each discrete time point
        # Follow the formula 3.3 on p.37, take main diagonal for final position wealth
        portfolio_wealth = np.diag(np.matmul(H.T, X_delta))
        portfolio_wealth_df = pd.DataFrame(portfolio_wealth, 
                                            index=[f"P_{n}" for n in range(len(portfolio_wealth))],
                                            columns=["Portfolio wealth"])
        return position_evolution_df, portfolio_wealth_df

    position_evolution_df, portfolio_wealth_df = generate_portfolio_process(number_of_assets=number_of_assets,
                                                                            discrete_periods=discrete_periods,
                                                                            start_process=start_process,
                                                                            sd_processes=sd_processes,
                                                                            mean_process=mean_process,
                                                                            low_position_size=low_position_size,
                                                                            high_position_size=high_position_size)

    def plot_portfolio_process(position_evolution_df: pd.DataFrame,
                               portfolio_wealth_df: pd.DataFrame):
        # Plot the evolution of the single positions as well as the overall wealth process
        fig = plt.figure(constrained_layout=True, figsize=(17, 6))
        subplots = [["Top", "Top"],
                    ["Bottom", "Bottom"]]
        axs = fig.subplot_mosaic(subplots)
        # plot the position evolution
        for col_name in position_evolution_df.T.columns:
            axs['Top'].plot(position_evolution_df.T[col_name], label=col_name)
        axs['Top'].set_title(f"Wealth evolution for {number_of_assets} assets over {discrete_periods} periods")
        axs['Top'].set_ylabel('Position value')
        axs['Top'].set_xticklabels(rotation=90, labels=position_evolution_df.columns)
        axs['Top'].grid(zorder=0)
        # plot the portfolio wealth
        axs["Bottom"].plot(portfolio_wealth_df, color="red")
        axs['Bottom'].set_title(f'Portfolio wealth evolution for {number_of_assets} assets over {discrete_periods} periods')
        axs['Bottom'].set_xlabel('Discrete Periods')
        axs['Bottom'].set_ylabel('Portfolio value')
        axs['Bottom'].set_xticklabels(rotation=90, labels=portfolio_wealth_df.index)
        axs['Bottom'].grid(zorder=0)
        plt.show()

    plot_portfolio_process(position_evolution_df=position_evolution_df,
                           portfolio_wealth_df=portfolio_wealth_df)

if __name__ == "__main__":
    main()